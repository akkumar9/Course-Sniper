#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
WebReg Monitor - Database-driven version (works with web frontend)
"""
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from webreg_bot import WebRegBot
import time
from datetime import datetime
import sqlite3

DB_PATH = 'webreg.db'

def get_active_courses():
    """Get all active courses from database"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT id, subject, course_num, email FROM courses WHERE active=1')
    courses = []
    for row in c.fetchall():
        courses.append({
            'id': row[0],
            'subject': row[1],
            'course_num': row[2],
            'email': row[3]
        })
    conn.close()
    return courses

def log_check(course_id, available_seats):
    """Log a check to database"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        'INSERT INTO checks (course_id, available_seats) VALUES (?, ?)',
        (course_id, available_seats)
    )
    conn.commit()
    conn.close()

def log_notification(course_id, available_seats, total_seats):
    """Log that we sent a notification"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        'INSERT INTO notifications (course_id, available_seats, total_seats) VALUES (?, ?, ?)',
        (course_id, available_seats, total_seats)
    )
    conn.commit()
    conn.close()

def was_recently_notified(course_id, minutes=60):
    """Check if we sent a notification recently"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        '''SELECT COUNT(*) FROM notifications 
           WHERE course_id=? AND sent_at > datetime('now', '-' || ? || ' minutes')''',
        (course_id, minutes)
    )
    count = c.fetchone()[0]
    conn.close()
    return count > 0

def was_sound_played_recently(course_id, minutes=60):
    """Check if we played sound recently (separate from email)"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    # Create sound_played table if it doesn't exist
    c.execute('''
        CREATE TABLE IF NOT EXISTS sound_played (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            course_id INTEGER,
            played_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (course_id) REFERENCES courses(id)
        )
    ''')
    
    c.execute(
        '''SELECT COUNT(*) FROM sound_played 
           WHERE course_id=? AND played_at > datetime('now', '-' || ? || ' minutes')''',
        (course_id, minutes)
    )
    count = c.fetchone()[0]
    conn.close()
    return count > 0

def log_sound_played(course_id):
    """Log that we played a sound"""
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        'INSERT INTO sound_played (course_id) VALUES (?)',
        (course_id,)
    )
    conn.commit()
    conn.close()

def send_email_notification(course, result):
    """Send email notification"""
    try:
        import smtplib
        from email.mime.text import MIMEText
        from email.mime.multipart import MIMEMultipart
        import json
        
        # Load email config
        with open('email_config.json', 'r') as f:
            config = json.load(f)
        
        to_email = course['email']
        subject = f"üîî {course['subject']} {course['course_num']} - Seats Available!"
        
        # Build sections list
        sections_text = ""
        for section in result['sections'][:10]:
            if section['available'] > 0:
                sections_text += f"<li>{section['available']}/{section['total']} seats</li>\n"
        
        body = f"""
        <html>
        <body>
            <h2>WebReg Alert!</h2>
            <p><strong>{course['subject']} {course['course_num']}</strong> has seats available!</p>
            
            <ul>{sections_text}</ul>
            
            <p><strong>Total: {result['total_available']} seats</strong></p>
            
            <p>
                <a href="https://act.ucsd.edu/webreg2/start" 
                   style="background-color: #667eea; color: white; padding: 15px 30px; 
                          text-decoration: none; border-radius: 10px; display: inline-block;">
                    Enroll Now ‚Üí
                </a>
            </p>
            
            <p style="color: gray; font-size: 12px; margin-top: 20px;">
                Checked at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
            </p>
        </body>
        </html>
        """
        
        msg = MIMEMultipart('alternative')
        msg['Subject'] = subject
        msg['From'] = config['sender_email']
        msg['To'] = to_email
        msg.attach(MIMEText(body, 'html'))
        
        with smtplib.SMTP_SSL('smtp.gmail.com', 465) as server:
            server.login(config['sender_email'], config['sender_password'])
            server.send_message(msg)
        
        print(f"‚úÖ Email sent to {to_email}")
        return True
        
    except FileNotFoundError:
        print("‚ö†Ô∏è  No email_config.json - skipping email")
        return False
    except Exception as e:
        print(f"‚ùå Email failed: {e}")
        return False

def main():
    print("\n" + "="*60)
    print("WEBREG MONITOR - Database Version")
    print("="*60)
    print("This works with the web frontend!")
    print("Add courses at: http://localhost:5000")
    print("="*60 + "\n")
    
    check_interval = 60  # seconds
    
    print(f"Check interval: {check_interval} seconds")
    print(f"Press Ctrl+C to stop\n")
    
    # Try logging in with retries
    max_login_attempts = 5
    bot = None
    
    for attempt in range(max_login_attempts):
        try:
            print("="*60)
            print(f"LOGIN ATTEMPT {attempt + 1}/{max_login_attempts}")
            print("="*60)
            
            # Close previous browser if exists
            if bot:
                print("Closing previous browser...")
                bot.close()
                time.sleep(2)
            
            # Create fresh bot
            bot = WebRegBot(headless=False)
            
            # Try to login
            bot.login_manual(use_cookies=True)
            
            # Test if login worked
            courses = get_active_courses()
            if courses:
                print("\nüîç Testing login with a quick search...")
                test_result = bot.search_course(courses[0]['subject'], courses[0]['course_num'])
                
                if test_result:
                    print("\n‚úÖ Login successful and verified!")
                    break
                else:
                    print("\n‚ö†Ô∏è  Login appeared to work but search failed")
                    if attempt < max_login_attempts - 1:
                        print(f"Retrying... (attempt {attempt + 2}/{max_login_attempts})")
                        time.sleep(3)
                        continue
            else:
                print("\n‚úÖ Login successful! (No courses to test yet)")
                break
                    
        except Exception as e:
            print(f"\n‚ùå Login attempt {attempt + 1} failed: {e}")
            if attempt < max_login_attempts - 1:
                print(f"Retrying... (attempt {attempt + 2}/{max_login_attempts})")
                time.sleep(3)
                continue
            else:
                print("\n‚ùå All login attempts failed!")
                if bot:
                    bot.close()
                return
    
    if not bot:
        print("\n‚ùå Could not initialize bot")
        return
    
    print("\n‚úÖ Ready to monitor! Starting checks...\n")
    
    try:
        iteration = 0
        consecutive_failures = 0
        max_consecutive_failures = 3
        
        while True:
            iteration += 1
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            
            print("\n" + "="*60)
            print(f"Check #{iteration} - {timestamp}")
            print("="*60)
            
            # Get fresh list of active courses
            courses = get_active_courses()
            
            if not courses:
                print("No active courses to monitor. Add some at http://localhost:5000")
                print(f"‚è∞ Waiting {check_interval} seconds...")
                time.sleep(check_interval)
                continue
            
            print(f"Monitoring {len(courses)} course(s)")
            
            at_least_one_success = False
            
            for course in courses:
                subject = course['subject']
                course_num = course['course_num']
                course_id = course['id']
                
                try:
                    print(f"\n[{subject} {course_num}] Checking...")
                    
                    result = bot.search_course(subject, course_num)
                    
                    if result:
                        at_least_one_success = True
                        consecutive_failures = 0
                        
                        # Log check
                        log_check(course_id, result['total_available'])
                        
                        if result.get('has_availability'):
                            total = result['total_available']
                            print(f"[{subject} {course_num}] ‚úÖ {total} SEATS AVAILABLE!")
                            
                            # ALWAYS send email when seats are available
                            # (user can pause course on website to stop emails)
                            print(f"[{subject} {course_num}] üìß Sending email notification...")
                            
                            # Play sound only ONCE per hour (not annoying)
                            if not was_sound_played_recently(course_id, minutes=60):
                                print(f"[{subject} {course_num}] üîä Playing sound alert...")
                                try:
                                    import subprocess
                                    import platform
                                    if platform.system() == "Darwin":
                                        subprocess.run(["afplay", "/System/Library/Sounds/Glass.aiff"], check=False)
                                        subprocess.run(["say", f"{subject} {course_num} has seats!"], check=False)
                                except:
                                    print("\a" * 3)
                                
                                log_sound_played(course_id)
                            else:
                                print(f"[{subject} {course_num}] üîá Sound skipped (played recently)")
                            
                            # Send email (always)
                            if send_email_notification(course, result):
                                log_notification(
                                    course_id,
                                    result['total_available'],
                                    sum(s['total'] for s in result['sections'])
                                )
                        else:
                            print(f"[{subject} {course_num}] No seats available")
                    else:
                        print(f"[{subject} {course_num}] ‚ö†Ô∏è  Could not get results")
                    
                    # Small delay between courses
                    time.sleep(3)
                    
                except Exception as e:
                    print(f"[{subject} {course_num}] ‚ùå Error: {e}")
            
            # Check if we had too many consecutive failures
            if not at_least_one_success and courses:
                consecutive_failures += 1
                print(f"\n‚ö†Ô∏è  No successful checks (failure {consecutive_failures}/{max_consecutive_failures})")
                
                if consecutive_failures >= max_consecutive_failures:
                    print("\n" + "="*60)
                    print("‚ö†Ô∏è  SESSION EXPIRED - NEED TO RE-LOGIN")
                    print("="*60)
                    print("Your WebReg session has expired (usually after 24 hours).")
                    print("Please log in again to continue monitoring.")
                    print("="*60 + "\n")
                    
                    # Try to refresh the session
                    bot.close()
                    time.sleep(2)
                    main()  # Restart with fresh login
                    return
            
            print(f"\n‚è∞ Waiting {check_interval} seconds...")
            time.sleep(check_interval)
            
    except KeyboardInterrupt:
        print("\n\n‚úã Stopped by user")
    finally:
        bot.close()
        print("üëã Browser closed")

if __name__ == "__main__":
    main()